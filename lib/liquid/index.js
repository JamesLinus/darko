// Generated by CoffeeScript 1.6.3
(function() {
  var Liquid, MONTHS, MONTH_ABBRS, Promise, WEEKDAYS, WEEKDAY_ABBRS, engine, formatDate, highlight, md,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Promise = require('bluebird');

  Liquid = require('liquid-node');

  md = require('../markdown');

  highlight = require('../highlight');

  WEEKDAY_ABBRS = 'Sun Mon Tue Wed Thu Fri Sat'.split(' ');

  WEEKDAYS = 'Sunday Monday Tuesday Wednesday Thursday Friday Saturday'.split(' ');

  MONTH_ABBRS = 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'.split(' ');

  MONTHS = 'January Feburary March April May June July August September October November December'.split(' ');

  formatDate = function(input, format) {
    var pad;
    if (input == null) {
      return input;
    }
    pad = function(str, chr, width) {
      var len;
      str = '' + str;
      len = Math.max(0, width - str.length);
      return Array(len + 1).join(chr) + str;
    };
    return format.replace(/%([a-zA-Z])/g, function(m, f) {
      var days, offset, prefix, _ref;
      switch (f) {
        case 'a':
          return WEEKDAY_ABBRS[input.getDay()];
        case 'A':
          return WEEKDAYS[input.getDay()];
        case 'b':
          return MONTH_ABBRS[input.getMonth()];
        case 'B':
          return MONTHS[input.getMonth()];
        case 'd':
          return pad(input.getDate(), '0', 2);
        case 'e':
          return input.getDate();
        case 'H':
          return pad(input.getHours(), '0', 2);
        case 'I':
          return pad(input.getHours() % 12, '0', 2);
        case 'j':
          days = (+input - (new Date(input.getFullYear(), 0, 1))) / 1000 / 60 / 60 / 24;
          return pad(days, '0', 3);
        case 'm':
          return pad(input.getMonth() + 1, '0', 2);
        case 'M':
          return pad(input.getMinutes(), '0', 2);
        case 'p':
          return (_ref = input.getHours() >= 12) != null ? _ref : {
            'PM': 'AM'
          };
        case 'S':
          return pad(input.getSeconds(), '0', 2);
        case 'w':
          return input.getDay();
        case 'y':
          return input.getFullYear() / 100;
        case 'Y':
          return input.getFullYear();
        case 'z':
          offset = -input.getTimezoneOffset() / 60;
          prefix = offset >= 0 ? '+' : '-';
          return prefix + pad(offset, '0', 2) + '00';
        default:
          return f;
      }
    });
  };

  engine = new Liquid.Engine;

  engine.registerTag("block", (function() {
    var BlockBlock;
    return BlockBlock = (function(_super) {
      var Syntax, SyntaxHelp;

      __extends(BlockBlock, _super);

      Syntax = /(\w+)/;

      SyntaxHelp = "Syntax Error in 'block' - Valid syntax: block [templateName]";

      function BlockBlock(template, tagName, markup, tokens) {
        var match;
        match = Syntax.exec(markup);
        if (!match) {
          throw new Liquid.SyntaxError(SyntaxHelp);
        }
        template.exportedBlocks || (template.exportedBlocks = {});
        template.exportedBlocks[match[1]] = this;
        BlockBlock.__super__.constructor.apply(this, arguments);
      }

      BlockBlock.prototype.replace = function(block) {
        return this.nodelist = block.nodelist;
      };

      return BlockBlock;

    })(Liquid.Block);
  })());

  engine.registerTag("highlight", (function() {
    var HighlightBlock, _ref;
    return HighlightBlock = (function(_super) {
      __extends(HighlightBlock, _super);

      function HighlightBlock() {
        _ref = HighlightBlock.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      HighlightBlock.prototype.render = function(context) {
        return highlight.render(this.nodelist.join('').trim(), this.markup);
      };

      return HighlightBlock;

    })(Liquid.Block);
  })());

  engine.registerTag("extends", (function() {
    var ExtendsTag;
    return ExtendsTag = (function(_super) {
      var Syntax, SyntaxHelp;

      __extends(ExtendsTag, _super);

      Syntax = /([a-z0-9\/\\_-]+)/i;

      SyntaxHelp = "Syntax Error in 'extends' - Valid syntax: extends [templateName]";

      function ExtendsTag(template, tagName, markup, tokens) {
        var match;
        match = Syntax.exec(markup);
        if (!match) {
          throw new Liquid.SyntaxError(SyntaxHelp);
        }
        template["extends"] = match[1];
        ExtendsTag.__super__.constructor.apply(this, arguments);
      }

      ExtendsTag.prototype.render = function(context) {
        return "";
      };

      return ExtendsTag;

    })(Liquid.Tag);
  })());

  engine.registerTag("include", (function() {
    var IncludeTag;
    return IncludeTag = (function(_super) {
      var AssignSyntax, Syntax, SyntaxHelp;

      __extends(IncludeTag, _super);

      Syntax = /([a-z0-9\/\\_-]+)/i;

      SyntaxHelp = "Syntax Error in 'include' - Valid syntax: include [templateName]";

      AssignSyntax = RegExp("((?:" + Liquid.VariableSignature.source + ")+)\\s*=\\s*((?:" + Liquid.QuotedFragment.source + "))");

      function IncludeTag(template, tagName, markup, tokens) {
        var deferred, match;
        match = Syntax.exec(markup);
        if (!match) {
          throw new Liquid.SyntaxError(SyntaxHelp);
        }
        this.filepath = match[1];
        deferred = Promise.defer();
        this.included = deferred.promise;
        match = AssignSyntax.exec(markup);
        if (match) {
          this.assignTo = match[1];
          this.assignFrom = match[2];
        }
        template.engine.importer(this.filepath, function(err, src) {
          var subTemplate;
          subTemplate = engine.extParse(src, template.engine.importer);
          return subTemplate.then(function(t) {
            return deferred.resolve(t);
          });
        });
        IncludeTag.__super__.constructor.apply(this, arguments);
      }

      IncludeTag.prototype.render = function(context) {
        var include;
        include = {};
        if (this.assignTo) {
          include[this.assignTo] = context.get(this.assignFrom);
        }
        context.lastScope().include = include;
        return this.included.then(function(i) {
          return i.render(context);
        });
      };

      return IncludeTag;

    })(Liquid.Tag);
  })());

  engine.registerFilter({
    capitalize: function(input) {
      return input && input.replace(/^([a-z])/, function(m, chr) {
        return chr.toUpperCase();
      });
    },
    date: formatDate,
    date_to_xmlschema: function(input) {
      return formatDate(input, '%Y-%m-%dT%H:%M:%S%z').replace(/00$/, ':00');
    },
    date_to_rfc822: function(input) {
      return formatDate(input, '%a, %d %b %Y %H:%M:%S %z');
    },
    date_to_string: function(input) {
      return formatDate(input, '%d %b %Y');
    },
    date_to_long_string: function(input) {
      return formatDate(input, '%d %B %Y');
    },
    xml_escape: function(input) {
      if (input == null) {
        return input;
      }
      return input.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    },
    cgi_escape: function(input) {
      input || (input = '');
      return encodeURIComponent(input).replace(/%20/g, '+');
    },
    uri_escape: function(input) {
      input || (input = '');
      return encodeURI(input).replace(/#/g, '%23');
    },
    array_to_sentence_string: function(input) {
      var i, item, res, _i, _len;
      res = '';
      for (i = _i = 0, _len = input.length; _i < _len; i = ++_i) {
        item = input[i];
        if (i + 1 === input.length) {
          res += 'and ' + item;
        } else {
          res += '' + item + ', ';
        }
      }
      return res;
    },
    markdownify: function(input) {
      return md(input);
    },
    jsonify: function(input) {
      return JSON.stringify(input);
    }
  });

  engine.extParse = function(src, importer) {
    var baseTemplate, deferred, depth, stack, walker,
      _this = this;
    if (!src) {
      throw new Error('Empty liquid template source');
    }
    engine.importer = importer;
    baseTemplate = engine.parse(src);
    if (!baseTemplate["extends"]) {
      return Promise.cast(baseTemplate);
    }
    deferred = Promise.defer();
    stack = [baseTemplate];
    depth = 0;
    walker = function(tmpl, cb) {
      if (!tmpl["extends"]) {
        return cb();
      }
      return tmpl.engine.importer(tmpl["extends"], function(err, data) {
        if (err) {
          return cb(err);
        }
        if (depth > 100) {
          return cb("too many `extends`");
        }
        depth++;
        return engine.extParse(data, importer).then(function(subTemplate) {
          stack.unshift(subTemplate);
          return walker(subTemplate, cb);
        })["catch"](function(err) {
          return cb(err != null ? err : "Failed to parse template.");
        });
      });
    };
    walker(stack[0], function(err) {
      var rootTemplate, subTemplates;
      if (err) {
        return deferred.reject(err);
      }
      rootTemplate = stack[0], subTemplates = 2 <= stack.length ? __slice.call(stack, 1) : [];
      subTemplates.forEach(function(subTemplate) {
        var k, rootTemplateBlocks, subTemplateBlocks, v, _ref, _results;
        subTemplateBlocks = subTemplate.exportedBlocks || {};
        rootTemplateBlocks = rootTemplate.exportedBlocks || {};
        _results = [];
        for (k in subTemplateBlocks) {
          if (!__hasProp.call(subTemplateBlocks, k)) continue;
          v = subTemplateBlocks[k];
          _results.push((_ref = rootTemplateBlocks[k]) != null ? _ref.replace(v) : void 0);
        }
        return _results;
      });
      return deferred.resolve(rootTemplate);
    });
    return deferred.promise;
  };

  module.exports = engine;

}).call(this);
